import Service from '@ember/service';
import { assert } from '@ember/debug';

const screenWidth = typeof screen !== 'undefined' ? screen.width : 320;

const extentionTypeMapping = new Map<string, ImageType>([['jpg', 'jpeg']]);

export type ImageType = 'png' | 'jpeg' | 'webp';

export interface ImageMeta {
  image: string;
  width: number;
  height: number;
  type: ImageType;
}

export interface Meta {
  images: ImageMeta[];
}

/**
 * Service class to provides images generated by the responsive images package
 *
 * @class ResponsiveImageService
 * @extends Service
 * @module responsive-image
 * @public
 */
export default class ResponsiveImageService extends Service {
  /**
   * the screen's width
   * This is the base value to calculate the image size.
   * That means the {{#crossLink "Services/ResponsiveImage:getImageBySize"}}getImageBySize{{/crossLink}} will return
   * an image that's close to `screenWidth *  window.devicePixelRatio * size / 100`
   *
   * @property screenWidth
   * @type {Number}
   * @public
   */
  screenWidth = screenWidth;

  /**
   * the physical width
   *
   * @property physicalWidth
   * @type {Number}
   * @public
   */
  physicalWidth = this.screenWidth * ((window && window.devicePixelRatio) || 1);

  /**
   * return the images with the different widths
   *
   * @method getImages
   * @param {String} imageName The origin name of the Image
   * @returns {Array} An array of objects with the image name and width, e.g. [{ width: 40, height: 20, image: myImage40w.jpg}, ...]
   * @public
   */
  getImages(imageName: string): ImageMeta[] {
    assert(
      `There is no data for image ${imageName}: ${this.meta}`,
      Object.prototype.hasOwnProperty.call(this.meta, imageName)
    );
    assert(
      `There is no image data for image ${imageName}`,
      Object.prototype.hasOwnProperty.call(this.meta[imageName], 'images')
    );
    return this.meta[imageName].images;
  }

  private getType(imageName: string): ImageType {
    const extension = imageName.split('.').pop();
    assert(`No extension found for ${imageName}`, extension);
    return extentionTypeMapping.get(extension) ?? (extension as ImageType);
  }

  /**
   * returns the image which fits for given size
   *
   * @method getImageBySize
   * @param {String} imageName The origin name of the Image
   * @param {Number} size The width of the image in percent of the screenwidth
   * @param {String} type The image type (jpeg, png, webp etc.)
   * @return {String} The url of the image
   * @public
   */
  getImageBySize(
    imageName: string,
    size?: number,
    type?: ImageType
  ): string | undefined {
    return this.getImageDataBySize(imageName, size, type)?.image;
  }

  /**
   * returns the image data which fits for given size
   *
   * @method getImageDataBySize
   * @param {String} imageName The origin name of the Image
   * @param {Number} size The width of the image in percent of the screenwidth
   * @param {String} type The image type (jpeg, png, webp etc.)
   * @return {Object} The data with image,width and height
   * @public
   */
  getImageDataBySize(
    imageName: string,
    size?: number,
    type: ImageType = this.getType(imageName)
  ): ImageMeta | undefined {
    const width = this.getDestinationImageWidthBySize(imageName, size);
    return this.getImages(imageName).find(
      (img) => img.width === width && img.type === type
    );
  }

  /**
   * returns the closest supported width to the screenwidth and size
   *
   * @method getDestinationImageWidthBySize
   * @param {String} imageName The name of the image
   * @param {Number} size The width of the image in percent of the screenwidth
   * @return {Number} the supported width
   * @private
   */
  getDestinationImageWidthBySize(imageName: string, size = 100): number {
    const destinationWidth = this.getDestinationWidthBySize(size);
    return this.getSupportedWidths(imageName).reduce((prevValue, item) => {
      if (item >= destinationWidth && prevValue >= destinationWidth) {
        return item >= prevValue ? prevValue : item;
      } else {
        return item >= prevValue ? item : prevValue;
      }
    }, 0);
  }

  /**
   * returns the supported widths of an image
   *
   * @method getSupportedWidths
   * @param {String} imageName the name of the image
   * @return {Number[]} the supported widths
   * @private
   */
  getSupportedWidths(imageName: string): number[] {
    return this.getImages(imageName).map((item) => {
      return item.width;
    });
  }

  /**
   * @method getDestinationWidthBySize
   * @param {Number} size returns the physical width factored by size
   * @returns {Number}
   * @private
   */
  getDestinationWidthBySize(size: number): number {
    const physicalWidth = this.physicalWidth;
    const factor = (size || 100) / 100;

    return physicalWidth * factor;
  }

  private _meta?: Record<string, Meta>;

  /**
   * the meta values from build time
   *
   * @property meta
   * @type {object}
   * @private
   */
  get meta(): Record<string, Meta> {
    if (this._meta) {
      return this._meta;
    }
    const script = document.getElementById('ember_responsive_image_meta');
    assert(
      'No script tag found containing meta data for ember-responsive-image',
      script?.textContent
    );
    const meta = JSON.parse(script.textContent);
    // eslint-disable-next-line ember/no-side-effects
    this._meta = meta;
    return meta;
  }
  set meta(meta: Record<string, Meta>) {
    this._meta = meta;
  }
}
